
"""
‚ï≠‚îÅ‚îÅ‚îÅ‚îÅ‚ïÆ‚ï≠‚ïÆ‚ï±‚ï±‚ï±‚ï±‚ï±‚ï≠‚îÅ‚îÅ‚îÅ‚ïÆ‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï≠‚ïÆ‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï≠‚ïÆ‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï≠‚ïÆ‚ï±‚ï±‚ï±‚ï≠‚îÅ‚îÅ‚îÅ‚ïÆ‚ï±‚ï±‚ï≠‚ïÆ
‚îÉ‚ï≠‚ïÆ‚ï≠‚ïÆ‚î£‚ïØ‚îÉ‚ï±‚ï±‚ï±‚ï±‚ï±‚îÉ‚ï≠‚îÅ‚ïÆ‚îÉ‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚îÉ‚îÉ‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï≠‚ïØ‚ï∞‚ïÆ‚ï±‚ï±‚ï±‚ï±‚ï±‚îÉ‚îÉ‚ï±‚ï±‚ï±‚îÉ‚ï≠‚îÅ‚ïÆ‚îÉ‚ï±‚ï±‚îÉ‚îÉ
‚ï∞‚ïØ‚îÉ‚îÉ‚ï∞‚îª‚ïÆ‚îÉ‚ï±‚ï±‚ï±‚ï±‚ï±‚îÉ‚ï∞‚îÅ‚ïØ‚î£‚îÅ‚î≥‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚î≥‚îÅ‚ïÆ‚ï≠‚îÅ‚îÅ‚î´‚ï∞‚îÅ‚î≥‚î≥‚ïÆ‚ï≠‚î≥‚îÅ‚îÅ‚î≥‚îÅ‚ïã‚ïÆ‚ï≠‚ïã‚îÅ‚îÅ‚ïÆ‚ï≠‚îÅ‚ïØ‚î£‚îÅ‚îÅ‚ïÆ‚îÉ‚ï∞‚îÅ‚ïØ‚î£‚îÅ‚îÅ‚î´‚îÉ‚ï≠‚î≥‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚î≥‚îÅ‚ïÆ‚ï≠‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚ïÆ
‚ï±‚ï±‚îÉ‚îÉ‚ï±‚ï±‚îÉ‚îÉ‚ï±‚ï≠‚îÅ‚îÅ‚ïÆ‚îÉ‚ï≠‚îÅ‚îÅ‚î´‚ï≠‚î´‚îÉ‚îÅ‚î´‚îÉ‚îÅ‚î´‚ï≠‚ïÆ‚î´‚ï≠‚îÅ‚î´‚ï≠‚ïÆ‚î£‚î´‚ï∞‚ïØ‚îÉ‚îÉ‚îÅ‚î´‚ï≠‚ïÆ‚î´‚îÉ‚îÉ‚ï≠‚ïÆ‚îÉ‚îÉ‚ï≠‚ïÆ‚îÉ‚îÉ‚îÅ‚î´‚îÉ‚ï≠‚îÅ‚îÅ‚î´‚ï≠‚ïÆ‚îÉ‚îÉ‚î£‚î´‚ï≠‚ïÆ‚îÉ‚ï≠‚ïÆ‚îÉ‚ï≠‚ïÆ‚î´‚ï≠‚ïÆ‚îÉ‚îÅ‚îÅ‚î´
‚ï±‚ï±‚îÉ‚îÉ‚ï±‚ï≠‚ïØ‚ï∞‚ïÆ‚ï∞‚îÅ‚îÅ‚ïØ‚îÉ‚îÉ‚ï±‚ï±‚îÉ‚îÉ‚îÉ‚îÉ‚îÅ‚î´‚îÉ‚îÅ‚î´‚îÉ‚îÉ‚îÉ‚ï∞‚îÅ‚î´‚îÉ‚îÉ‚îÉ‚îÉ‚îÉ‚îÉ‚îÉ‚îÉ‚îÅ‚î´‚îÉ‚îÉ‚îÉ‚ï∞‚î´‚ï∞‚ïØ‚îÉ‚îÉ‚ï∞‚ïØ‚îÉ‚îÉ‚îÅ‚î´‚îÉ‚îÉ‚ï±‚ï±‚îÉ‚ï∞‚ïØ‚îÉ‚ï∞‚î´‚îÉ‚ï∞‚ïØ‚îÉ‚ï∞‚ïØ‚îÉ‚îÉ‚îÉ‚îÉ‚ï∞‚ïØ‚î£‚îÅ‚îÅ‚îÉ
‚ï±‚ï±‚ï∞‚ïØ‚ï±‚ï∞‚îÅ‚îÅ‚ïØ‚ï±‚ï±‚ï±‚ï±‚ï∞‚ïØ‚ï±‚ï±‚ï∞‚ïØ‚ï∞‚îÅ‚îÅ‚îª‚îÅ‚îÅ‚îª‚ïØ‚ï∞‚îª‚îÅ‚îÅ‚îª‚ïØ‚ï∞‚îª‚îª‚îª‚îª‚îª‚îÅ‚îÅ‚îª‚ïØ‚ï∞‚îª‚îÅ‚îª‚îÅ‚îÅ‚ïØ‚ï∞‚îÅ‚îÅ‚îª‚îÅ‚îÅ‚ïØ‚ï∞‚ïØ‚ï±‚ï±‚ï∞‚îÅ‚îÅ‚îª‚îÅ‚îª‚îª‚îÅ‚ïÆ‚î£‚îÅ‚îÅ‚îª‚ïØ‚ï∞‚îª‚îÅ‚îÅ‚îª‚îÅ‚îÅ‚ïØ
‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï±‚ï≠‚îÅ‚ïØ‚îÉ
----------------------------------------------------------------

Ian de Holanda Cavalcanti Bezerra - 13835412
Julia Graziosi Ortiz - 11797810

"""

# =============================================================================
# IMPORTA√á√ÉO DE BIBLIOTECAS
# =============================================================================

"""
PyGame √© utilizado para criar uma interface gr√°fica interativa que permite:
- Visualiza√ß√£o em tempo real do processo de constru√ß√£o de pol√≠gonos
- Intera√ß√£o com mouse e teclado para adicionar/remover v√©rtices
- Demonstra√ß√£o visual do algoritmo de preenchimento scanline
- Exibi√ß√£o de informa√ß√µes de valida√ß√£o do pol√≠gono

Futuramente, podemos integrar com OpenGL para melhor performance
em problemas maiores de computa√ß√£o gr√°fica.
"""

import sys
import math
import pygame
from typing import List, Optional, Tuple


# =============================================================================
# CONSTANTES E CONFIGURA√á√ïES DA APLICA√á√ÉO
# =============================================================================

# Dimens√µes da grade (matriz de c√©lulas onde o usu√°rio pode clicar)
COLUNAS_GRADE, LINHAS_GRADE = 60, 60

# Configura√ß√µes visuais da interface
TAMANHO_CELULA = 20  # Tamanho de cada c√©lula da grade em pixels
MARGEM = 32          # Margem ao redor da grade para o HUD e espa√ßamento

# C√°lculo autom√°tico das dimens√µes da janela
LARGURA_JANELA = COLUNAS_GRADE * TAMANHO_CELULA + MARGEM * 2
ALTURA_JANELA = LINHAS_GRADE * TAMANHO_CELULA + MARGEM * 2
FPS = 60  # Taxa de atualiza√ß√£o da tela (frames por segundo)

# =============================================================================
# PALETA DE CORES (RGB)
# =============================================================================

# Cores b√°sicas
BRANCO = (240, 240, 240)
PRETO = (30, 30, 30)

# Elementos da grade
LINHA_GRADE = (120, 120, 120)      # Cor das linhas da grade
XADREZ_A = (210, 210, 210)         # Tom mais escuro do padr√£o xadrez
XADREZ_B = (245, 245, 245)         # Tom mais claro do padr√£o xadrez

# Elementos do pol√≠gono
VERTICE_ATUAL = (50, 140, 255)     # Azul - v√©rtice sendo posicionado
VERTICE_ANTERIOR = (40, 200, 120)  # Verde - v√©rtices j√° posicionados
VERTICE_PRIMEIRO = (255, 50, 50)   # Vermelho - primeiro v√©rtice do pol√≠gono

# Estados das linhas
LINHA_TEMPORARIA = (255, 200, 0)   # Amarelo - linha tempor√°ria at√© o mouse
LINHA_PREVIEW = (0, 0, 0)          # Preto - linhas do pol√≠gono validado

# Preenchimento e interface
CELULA_POLIGONO = (220, 60, 60)    # Vermelho escuro - c√©lulas preenchidas do pol√≠gono
TEXTO_HUD = (20, 20, 20)           # Cinza escuro - texto do painel informativo

# =============================================================================
# TIPOS PERSONALIZADOS
# =============================================================================

# Representa uma coordenada (coluna, linha) na grade
CelulaNaGrade = Tuple[int, int]

# =============================================================================
# FUN√á√ïES UTILIT√ÅRIAS - CONVERS√ÉO DE COORDENADAS
# =============================================================================

"""
Este m√≥dulo cont√©m fun√ß√µes para converter coordenadas entre diferentes sistemas:

1. Sistema da Grade: coordenadas discretas (coluna, linha) da matriz de c√©lulas
2. Sistema da Tela: coordenadas cont√≠nuas em pixels da janela PyGame

Essas convers√µes s√£o essenciais para mapear cliques do mouse na tela
para posi√ß√µes na grade, e vice-versa.
"""

def grade_para_tela(celula: CelulaNaGrade) -> Tuple[int, int]:
    """
    Converte coordenadas da grade para coordenadas da tela (pixels).

    Args:
        celula: Tupla (coluna, linha) representando uma posi√ß√£o na grade

    Returns:
        Tupla (x, y) com as coordenadas em pixels na tela
    """
    col, linha = celula
    x = MARGEM + col * TAMANHO_CELULA
    y = MARGEM + linha * TAMANHO_CELULA
    return x, y

def centro_celula(celula: CelulaNaGrade) -> Tuple[int, int]:
    """
    Calcula o centro de uma c√©lula da grade em coordenadas da tela.

    Args:
        celula: Tupla (coluna, linha) da c√©lula

    Returns:
        Tupla (x, y) do centro da c√©lula em pixels
    """
    x, y = grade_para_tela(celula)
    return x + TAMANHO_CELULA // 2, y + TAMANHO_CELULA // 2

def restringir_celula(celula: CelulaNaGrade) -> CelulaNaGrade:
    """
    Restringe uma coordenada da grade aos limites v√°lidos da matriz.

    Args:
        celula: Tupla (coluna, linha) que pode estar fora dos limites

    Returns:
        Tupla (coluna, linha) garantidamente dentro dos limites da grade
    """
    col, linha = celula
    col = max(0, min(COLUNAS_GRADE - 1, col))
    linha = max(0, min(LINHAS_GRADE - 1, linha))
    return col, linha

def tela_para_grade(pos: Tuple[int, int]) -> Optional[CelulaNaGrade]:
    """
    Converte coordenadas da tela (pixels) para coordenadas da grade.

    Args:
        pos: Tupla (x, y) com posi√ß√£o em pixels na tela

    Returns:
        Tupla (coluna, linha) se a posi√ß√£o estiver dentro da grade, None caso contr√°rio
    """
    x, y = pos
    x_rel = x - MARGEM  # Remove a margem esquerda
    y_rel = y - MARGEM  # Remove a margem superior

    # Verifica se o clique est√° dentro da √°rea da grade
    if x_rel < 0 or y_rel < 0:
        return None

    # Converte pixels para √≠ndices da grade
    col = x_rel // TAMANHO_CELULA
    linha = y_rel // TAMANHO_CELULA

    # Verifica se os √≠ndices est√£o dentro dos limites da grade
    if 0 <= col < COLUNAS_GRADE and 0 <= linha < LINHAS_GRADE:
        return int(col), int(linha)
    return None

# =============================================================================
# ALGORITMO DE DETEC√á√ÉO DE INTERSE√á√ÉO ENTRE SEGMENTOS
# =============================================================================

"""
Este m√≥dulo implementa o algoritmo matem√°tico para detectar se dois segmentos de reta
se interceptam no plano cartesiano. √â fundamental para validar se um pol√≠gono
possui auto-interse√ß√£o (arestas que se cruzam).

O algoritmo utiliza o conceito de "orienta√ß√£o" dos pontos:
- Se tr√™s pontos s√£o colineares: orienta√ß√£o = 0
- Se formam uma curva √† esquerda: orienta√ß√£o = 1 (sentido anti-hor√°rio)
- Se formam uma curva √† direita: orienta√ß√£o = 2 (sentido hor√°rio)

Dois segmentos se interceptam se:
1. Os pontos de cada segmento estiverem em lados opostos da reta do outro segmento
2. Ou se houver sobreposi√ß√£o/colinearidade entre os segmentos
"""

def segmentos_se_interceptam(p1, q1, p2, q2):
    """
    Verifica se dois segmentos de reta se interceptam.

    Args:
        p1, q1: Pontos extremos do primeiro segmento [(x1,y1), (x2,y2)]
        p2, q2: Pontos extremos do segundo segmento [(x3,y3), (x4,y4)]

    Returns:
        True se os segmentos se interceptam, False caso contr√°rio

    Algoritmo:
    1. Calcula a orienta√ß√£o dos pontos para determinar posi√ß√µes relativas
    2. Verifica se os segmentos se cruzam (caso geral)
    3. Trata casos especiais de colinearidade e sobreposi√ß√£o
    """

    def orientacao(p, q, r):
        """
        Calcula a orienta√ß√£o de tr√™s pontos no plano.

        Args:
            p, q, r: Tr√™s pontos no plano cartesiano

        Returns:
            0: pontos colineares (na mesma reta)
            1: orienta√ß√£o anti-hor√°ria (esquerda)
            2: orienta√ß√£o hor√°ria (direita)
        """
        # F√≥rmula matem√°tica: (q_y - p_y) * (r_x - q_x) - (q_x - p_x) * (r_y - q_y)
        # Resultado positivo = anti-hor√°rio, negativo = hor√°rio, zero = colinear
        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])
        if val == 0: return 0  # Colineares
        return 1 if val > 0 else 2  # 1 = esquerda, 2 = direita

    def ponto_no_segmento(p, q, r):
        """
        Verifica se o ponto q est√° sobre o segmento de reta definido por p e r.

        Args:
            p, r: Pontos extremos do segmento
            q: Ponto a ser testado

        Returns:
            True se q estiver sobre o segmento pr, False caso contr√°rio
        """
        # Verifica se q est√° dentro da bounding box do segmento
        return (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and
                q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1]))

    # Calcula orienta√ß√µes dos pontos dos segmentos
    o1 = orientacao(p1, q1, p2)  # Orienta√ß√£o de p2 em rela√ß√£o ao segmento p1q1
    o2 = orientacao(p1, q1, q2)  # Orienta√ß√£o de q2 em rela√ß√£o ao segmento p1q1
    o3 = orientacao(p2, q2, p1)  # Orienta√ß√£o de p1 em rela√ß√£o ao segmento p2q2
    o4 = orientacao(p2, q2, q1)  # Orienta√ß√£o de q1 em rela√ß√£o ao segmento p2q2

    # Caso geral: segmentos se cruzam se os pontos estiverem em lados opostos
    if o1 != o2 and o3 != o4:
        return True

    # Casos especiais: tratamento de colinearidade e sobreposi√ß√£o
    if o1 == 0 and ponto_no_segmento(p1, p2, q1): return True  # p2 sobre p1q1
    if o2 == 0 and ponto_no_segmento(p1, q2, q1): return True  # q2 sobre p1q1
    if o3 == 0 and ponto_no_segmento(p2, p1, q2): return True  # p1 sobre p2q2
    if o4 == 0 and ponto_no_segmento(p2, q1, q2): return True  # q1 sobre p2q2

    return False

# =============================================================================
# VALIDA√á√ÉO DE POL√çGONOS
# =============================================================================

"""
Este m√≥dulo cont√©m fun√ß√µes para validar se um conjunto de v√©rtices forma um pol√≠gono v√°lido.
Um pol√≠gono √© considerado v√°lido se:

1. Possui pelo menos 3 v√©rtices (m√≠nimo para formar uma forma fechada)
2. N√£o possui v√©rtices duplicados consecutivos
3. Est√° fechado (√∫ltimo v√©rtice igual ao primeiro)
4. N√£o possui auto-interse√ß√£o (arestas n√£o se cruzam)

A valida√ß√£o √© crucial para garantir que o pol√≠gono pode ser preenchido
corretamente pelo algoritmo scanline sem ambiguidades.
"""

def poligono_e_valido(vertices: List[CelulaNaGrade]) -> Tuple[bool, str]:
    """
    Valida se um conjunto de v√©rtices forma um pol√≠gono v√°lido.

    Args:
        vertices: Lista de coordenadas (coluna, linha) dos v√©rtices do pol√≠gono

    Returns:
        Tupla (v√°lido, mensagem):
        - v√°lido: True se o pol√≠gono √© v√°lido, False caso contr√°rio
        - mensagem: Descri√ß√£o detalhada do resultado da valida√ß√£o

    Crit√©rios de valida√ß√£o:
    1. M√≠nimo de 3 v√©rtices
    2. Sem v√©rtices duplicados consecutivos
    3. Pol√≠gono fechado (√∫ltimo = primeiro v√©rtice)
    4. Sem auto-interse√ß√£o entre arestas
    """

    # =================================================================
    # VALIDA√á√ÉO 1: N√∫mero m√≠nimo de v√©rtices
    # =================================================================
    if len(vertices) < 3:
        return False, "‚ùå Pol√≠gono precisa ter pelo menos 3 v√©rtices"

    # =================================================================
    # VALIDA√á√ÉO 2: V√©rtices duplicados consecutivos
    # =================================================================
    for i in range(len(vertices) - 1):
        if vertices[i] == vertices[i + 1]:
            return False, "‚ùå Pol√≠gono possui v√©rtices duplicados consecutivos"

    # =================================================================
    # VALIDA√á√ÉO 3: Pol√≠gono fechado
    # =================================================================
    if vertices[0] != vertices[-1]:
        return False, "‚ùå Pol√≠gono n√£o est√° fechado (√∫ltimo v√©rtice deve ser igual ao primeiro)"

    # =================================================================
    # VALIDA√á√ÉO 4: Auto-interse√ß√£o
    # =================================================================

    # Remove o √∫ltimo v√©rtice duplicado para an√°lise (pol√≠gono j√° validado como fechado)
    vertices_unicos = vertices[:-1]
    n = len(vertices_unicos)

    # Verifica todas as combina√ß√µes de arestas para detectar interse√ß√µes
    for i in range(n):
        for j in range(i + 2, n):
            # Pula a verifica√ß√£o da aresta que conecta o √∫ltimo ao primeiro v√©rtice
            # quando i=0 e j=n-1 (essa aresta √© adjacente e n√£o pode se auto-intersetar)
            if (i == 0 and j == n - 1):
                continue

            # Define os pontos das duas arestas a serem comparadas
            p1, q1 = vertices_unicos[i], vertices_unicos[(i + 1) % n]  # Aresta i
            p2, q2 = vertices_unicos[j], vertices_unicos[(j + 1) % n]  # Aresta j

            # Verifica se as arestas se interceptam
            if segmentos_se_interceptam(p1, q1, p2, q2):
                return False, "‚ùå Pol√≠gono possui auto-interse√ß√£o (linhas se cruzam)"

    # =================================================================
    # POL√çGONO V√ÅLIDO
    # =================================================================
    return True, "‚úÖ Pol√≠gono v√°lido: fechado e sem auto-interse√ß√£o"

# =============================================================================
# ALGORITMO SCANLINE FILL - PREENCHIMENTO DE POL√çGONOS
# =============================================================================

"""
Este m√≥dulo implementa o algoritmo Scanline Fill, uma t√©cnica cl√°ssica de
computa√ß√£o gr√°fica para preencher o interior de pol√≠gonos rasterizando linha por linha.

O algoritmo funciona em duas fases principais:

FASE 1: CONSTRU√á√ÉO DA TABELA DE ARESTAS (EDGE TABLE)
- Analisa todas as arestas do pol√≠gono
- Agrupa arestas por coordenada Y m√≠nima
- Calcula inclina√ß√µes e pontos de interse√ß√£o

FASE 2: VARREDURA LINHA A LINHA (SCANLINE SWEEP)
- Processa cada linha Y da parte superior √† inferior
- Mant√©m lista de arestas ativas que interceptam a linha atual
- Calcula intervalos de preenchimento entre interse√ß√µes pares
"""

class Edge:
    """
    Representa uma aresta do pol√≠gono na tabela de arestas.

    Atributos:
        ymax: Coordenada Y m√°xima da aresta (ponto final)
        xmin: Coordenada X atual da aresta (atualizada durante varredura)
        inv_slope: Inverso da inclina√ß√£o (1/m) para atualizar X durante varredura
    """
    def __init__(self, ymax, xmin, inv_slope):
        self.ymax = ymax          # Y m√°ximo (limite superior da aresta)
        self.xmin = xmin          # X atual (atualizado durante scanline)
        self.inv_slope = inv_slope # Œîx/Œîy (usado para mover aresta)

def build_edge_table(vertices: List[CelulaNaGrade]):
    """
    Constr√≥i a Edge Table (ET) organizando todas as arestas do pol√≠gono.

    Args:
        vertices: Lista de v√©rtices do pol√≠gono (x, y)

    Returns:
        Tupla (ET, min_y, max_y):
        - ET: Dicion√°rio onde chave=y_min e valor=lista de arestas
        - min_y, max_y: Limites Y do pol√≠gono para varredura

    Algoritmo:
    1. Para cada aresta do pol√≠gono (conectando v√©rtices consecutivos)
    2. Calcula y_min, y_max, x_min inicial e inclina√ß√£o
    3. Agrupa arestas por y_min na Edge Table
    4. Ordena arestas em cada n√≠vel Y por coordenada X
    """

    ET = {}  # Edge Table: {y_min: [lista_de_arestas]}
    n = len(vertices)

    # Inicializa limites Y com primeiro v√©rtice
    min_y = vertices[0][1]
    max_y = vertices[0][1]

    # Processa cada aresta do pol√≠gono
    for i in range(n):
        x1, y1 = vertices[i]
        x2, y2 = vertices[(i + 1) % n]  # Pr√≥ximo v√©rtice (circular)

        # Pula arestas horizontais (n√£o contribuem para preenchimento)
        if y1 == y2:
            continue

        # Calcula par√¢metros da aresta
        ymin = min(y1, y2)          # Y m√≠nimo da aresta
        ymax = max(y1, y2)          # Y m√°ximo da aresta
        inv_slope = (x2 - x1) / (y2 - y1)  # Inclina√ß√£o (Œîx/Œîy)
        xmin = x1 if y1 == ymin else x2    # X inicial (no ponto y_min)

        # Adiciona aresta √† Edge Table
        if ymin not in ET:
            ET[ymin] = []
        ET[ymin].append(Edge(ymax, xmin, inv_slope))

        # Atualiza limites globais Y
        min_y = min(min_y, ymin)
        max_y = max(max_y, ymax)

    # Ordena arestas em cada n√≠vel Y por coordenada X (importante para scanline)
    for k in ET:
        ET[k].sort(key=lambda e: e.xmin)

    return ET, min_y, max_y

def scanline_fill(ET, min_y, max_y):
    """
    Executa o algoritmo scanline para calcular pontos de preenchimento.

    Args:
        ET: Edge Table com arestas organizadas por y_min
        min_y, max_y: Limites Y para varredura

    Returns:
        Lista de tuplas (y, [x_interse√ß√µes]) para cada linha varrida

    Algoritmo:
    1. Para cada linha Y de min_y at√© max_y:
       a. Adiciona arestas que come√ßam nesta linha (ET[y])
       b. Remove arestas que terminam nesta linha (ymax == y)
       c. Calcula interse√ß√µes X ordenadas
       d. Registra interse√ß√µes para preenchimento posterior
       e. Atualiza posi√ß√µes X das arestas ativas
    """

    AET = []  # Active Edge Table - arestas interceptando linha atual
    y = min_y
    scanline_results = []  # Resultados: [(y, [x1, x2, x3, ...]), ...]

    while y <= max_y:
        # 1. Adiciona arestas que come√ßam nesta linha Y
        if y in ET:
            AET.extend(ET[y])  # Adiciona todas as arestas que come√ßam em y

        # 2. Remove arestas que terminam nesta linha Y
        AET = [e for e in AET if e.ymax != y]

        # 3. Ordena arestas ativas por coordenada X atual
        AET.sort(key=lambda e: e.xmin)

        # 4. Extrai coordenadas X das interse√ß√µes
        intercepts = [e.xmin for e in AET]

        # 5. Registra resultado desta linha para preenchimento posterior
        scanline_results.append((y, intercepts.copy()))

        # 6. Atualiza posi√ß√µes X das arestas ativas para pr√≥xima linha
        for e in AET:
            e.xmin += e.inv_slope  # Move aresta pela inclina√ß√£o

        y += 1  # Pr√≥xima linha de varredura

    return scanline_results


# FUN√á√ïES DE RENDERIZA√á√ÉO GR√ÅFICA (PYGAME)

def desenhar_tabuleiro(surface):
    # Preenche cada c√©lula com cor alternada (padr√£o xadrez)
    for linha in range(LINHAS_GRADE):
        for col in range(COLUNAS_GRADE):
            x, y = grade_para_tela((col, linha))  # Converte coordenadas da grade
            rect = pygame.Rect(x, y, TAMANHO_CELULA, TAMANHO_CELULA)

            # Alterna cores baseado na soma linha + coluna (padr√£o xadrez)
            cor = XADREZ_A if (linha + col) % 2 == 0 else XADREZ_B
            surface.fill(cor, rect)

    # Desenha linhas verticais da grade
    for c in range(COLUNAS_GRADE + 1):
        x = MARGEM + c * TAMANHO_CELULA
        pygame.draw.line(surface, LINHA_GRADE,
                        (x, MARGEM),  # Ponto inicial
                        (x, MARGEM + LINHAS_GRADE * TAMANHO_CELULA),  # Ponto final
                        1)  # Espessura da linha

    # Desenha linhas horizontais da grade
    for r in range(LINHAS_GRADE + 1):
        y = MARGEM + r * TAMANHO_CELULA
        pygame.draw.line(surface, LINHA_GRADE,
                        (MARGEM, y),  # Ponto inicial
                        (MARGEM + COLUNAS_GRADE * TAMANHO_CELULA, y),  # Ponto final
                        1)  # Espessura da linha

def desenhar_vertices(surface, vertices, poligono_validado):
    if not vertices:
        return

    poligono_fechado = len(vertices) >= 4 and vertices[0] == vertices[-1]

    for i, vertice in enumerate(vertices):
        vx, vy = centro_celula(vertice)  # Centro da c√©lula em pixels

        if poligono_fechado and i == len(vertices) - 1:
            continue

        if i == 0:
            pygame.draw.circle(surface, VERTICE_PRIMEIRO, (vx, vy), TAMANHO_CELULA // 3)

            if len(vertices) >= 3 and not poligono_fechado:
                pygame.draw.circle(surface, VERTICE_PRIMEIRO, (vx, vy), TAMANHO_CELULA // 2, 2)

        elif i == len(vertices) - 1:
            pygame.draw.circle(surface, VERTICE_ATUAL, (vx, vy), TAMANHO_CELULA // 3)

        else:
            cor = PRETO if poligono_validado else VERTICE_ANTERIOR
            pygame.draw.circle(surface, cor, (vx, vy), TAMANHO_CELULA // 3)

def desenhar_linhas_preview(surface, vertices, poligono_validado):
    if len(vertices) < 2:
        return  # Precisa de pelo menos 2 v√©rtices para desenhar linha

    # Prepara lista de v√©rtices para desenhar (remove duplicata se fechado)
    vertices_para_desenhar = vertices[:]
    poligono_fechado = len(vertices) >= 4 and vertices[0] == vertices[-1]

    if poligono_fechado:
        vertices_para_desenhar = vertices[:-1]  # Remove √∫ltimo v√©rtice duplicado

    # Define cor das linhas baseada na valida√ß√£o
    cor = PRETO if poligono_validado else LINHA_PREVIEW

    # Conecta v√©rtices consecutivos com linhas
    for i in range(len(vertices_para_desenhar) - 1):
        p1_x, p1_y = centro_celula(vertices_para_desenhar[i])     # V√©rtice atual
        p2_x, p2_y = centro_celula(vertices_para_desenhar[i + 1]) # Pr√≥ximo v√©rtice

        pygame.draw.line(surface, cor, (p1_x, p1_y), (p2_x, p2_y), 3)

    # Conecta √∫ltimo v√©rtice de volta ao primeiro para fechar o pol√≠gono
    if poligono_fechado and len(vertices_para_desenhar) >= 3:
        p1_x, p1_y = centro_celula(vertices_para_desenhar[-1])  # √öltimo v√©rtice
        p2_x, p2_y = centro_celula(vertices_para_desenhar[0])   # Primeiro v√©rtice

        pygame.draw.line(surface, cor, (p1_x, p1_y), (p2_x, p2_y), 3)

def desenhar_celulas_poligono(surface, pontos, passos_mostrados):
    """
    Desenha as c√©lulas preenchidas do pol√≠gono durante a anima√ß√£o scanline.

    Args:
        surface: Superf√≠cie PyGame onde desenhar
        pontos: Lista de coordenadas (col, linha) das c√©lulas a preencher
        passos_mostrados: N√∫mero de c√©lulas a mostrar (para anima√ß√£o gradual)

    Visual:
    - Preenche c√©lulas com cor vermelha escura
    - Anima√ß√£o progressiva mostra o preenchimento linha por linha
    - Margem interna evita sobrepor as linhas da grade
    """

    # Processa apenas as c√©lulas at√© o passo atual da anima√ß√£o
    for i, (col, linha) in enumerate(pontos[:passos_mostrados]):
        x, y = grade_para_tela((col, linha))

        # Cria ret√¢ngulo menor que a c√©lula (margem de 2 pixels)
        # Evita sobrepor as linhas da grade
        rect = pygame.Rect(x + 2, y + 2, TAMANHO_CELULA - 4, TAMANHO_CELULA - 4)

        # Preenche com cor vermelha escura
        surface.fill(CELULA_POLIGONO, rect)

def desenhar_interceptos(surface, interceptos, passo_atual):
    if passo_atual >= len(interceptos):
        return

    # Obt√©m dados da linha atual sendo processada
    y, xs = interceptos[passo_atual]

    # Converte coordenada Y da grade para pixels na tela
    y_tela = MARGEM + y * TAMANHO_CELULA

    # Desenha linha vermelha horizontal marcando a scanline atual
    pygame.draw.line(surface, (255, 0, 0),  # Vermelho
                    (MARGEM, y_tela + TAMANHO_CELULA // 2),  # Centro vertical da linha
                    (LARGURA_JANELA - MARGEM, y_tela + TAMANHO_CELULA // 2),
                    2)  # Espessura da linha

    # =================================================================
    # DESENHO DOS PONTOS DE INTERSE√á√ÉO
    # =================================================================

    # Para cada interse√ß√£o X na linha atual
    for x in xs:
        x_int = int(x)  # Converte para inteiro (posi√ß√£o da grade)
        x_tela = MARGEM + x_int * TAMANHO_CELULA + TAMANHO_CELULA // 2

        # Desenha c√≠rculo verde marcando o ponto de interse√ß√£o
        pygame.draw.circle(surface, (0, 255, 0),  # Verde
                          (x_tela, y_tela + TAMANHO_CELULA // 2),
                          5)  # Raio do c√≠rculo

def desenhar_hud(surface, font, vertices, poligono_validado, resultado_validacao, passos_mostrados, total_pontos):
    linhas = [
        "=== Validador de Pol√≠gonos ===",
        "Click: Adicionar v√©rtice",
        "ENTER: Validar | SPACE: Limpar | BACKSPACE: Remover | ESC: Sair | N: Scanline",
        "",
    ]

    num_vertices = len(vertices)

    linhas.append(f"V√©rtices: {num_vertices}")

    if num_vertices > 0:
        linhas.append(f"√öltimo v√©rtice: {vertices[-1]}")

    if poligono_validado:
        linhas.append("Status: Pol√≠gono validado ‚úì")
    elif num_vertices >= 4 and vertices[0] == vertices[-1]:
        linhas.append("Status: Pol√≠gono fechado! Pressione ENTER para validar")
    elif num_vertices >= 3:
        linhas.append("Status: Clique no primeiro v√©rtice para fechar, ou ENTER para validar")
    else:
        linhas.append("Status: Adicione mais v√©rtices (m√≠n. 3)")

    if resultado_validacao:
        linhas.append("")
        linhas.append("=== Resultado da Valida√ß√£o ===")
        linhas.append(resultado_validacao)

    if total_pontos > 0:
        linhas.append("")
        linhas.append(f"Pontos desenhados: {passos_mostrados}/{total_pontos}")

    if vertices:
        linhas.append("")
        linhas.append("=== V√©rtices do Pol√≠gono ===")

        for i, vertice in enumerate(vertices):
            # Emojis para identificar tipo do v√©rtice
            if i == 0:
                cor_info = "üî¥"  # Primeiro v√©rtice
            elif i == len(vertices) - 1:
                cor_info = "üîµ"  # √öltimo v√©rtice
            else:
                cor_info = "‚ö™"  # V√©rtices intermedi√°rios

            linhas.append(f"{cor_info} V{i+1}: {vertice}")

            # Limita o n√∫mero de linhas para n√£o sobrecarregar a tela
            if len(linhas) > 20:
                linhas.append("...")
                break

    x, y = 16, 8  # Posi√ß√£o inicial do texto

    for texto in linhas:
        # Define cor do texto baseada no conte√∫do
        cor = TEXTO_HUD  # Cor padr√£o (cinza escuro)

        if "===" in texto:
            cor = (0, 100, 200)  # Azul para t√≠tulos de se√ß√£o
        elif "Status:" in texto:
            if "validado" in texto:
                cor = (0, 150, 0)    # Verde para status v√°lido
            elif "ENTER" in texto:
                cor = (200, 100, 0)  # Laranja para instru√ß√µes
            else:
                cor = (150, 150, 0)  # Amarelo para outros status
        elif "v√°lido" in texto.lower():
            if "sem auto-interse√ß√£o" in texto:
                cor = (0, 150, 0)    # Verde para v√°lido
            else:
                cor = (200, 50, 50)  # Vermelho para inv√°lido
        elif texto.startswith("üî¥") or texto.startswith("üîµ") or texto.startswith("‚ö™"):
            cor = (100, 100, 100)  # Cinza para lista de v√©rtices

        # Renderiza e desenha o texto
        surf = font.render(texto, True, cor)
        surface.blit(surf, (x, y))
        y += surf.get_height() + 2  # Pr√≥xima linha

class EstadoApp:
    def __init__(self):
        """Inicializa o estado da aplica√ß√£o com valores padr√£o."""

        self.vertices: List[CelulaNaGrade] = []        
        self.poligono_validado: bool = False          
        self.resultado_validacao: str = ""           

        self.pontos_raster: List[CelulaNaGrade] = [] 
        self.interceptos_scanline: List[Tuple[int, List[float]]] = []
        self.scanline_step: int = 0                  

    def limpar_raster(self):
        self.pontos_raster = []
        self.interceptos_scanline = []
        self.scanline_step = 0

    def adicionar_vertice(self, celula: CelulaNaGrade):
        if not self.poligono_validado:
            vertice_restrito = restringir_celula(celula)

            if len(self.vertices) >= 3 and vertice_restrito == self.vertices[0]:
                self.vertices.append(vertice_restrito)
                print("Pol√≠gono fechado automaticamente! Pressione ENTER para validar.")
                return

            if not self.vertices or self.vertices[-1] != vertice_restrito:
                self.vertices.append(vertice_restrito)

    def validar_e_desenhar_poligono(self):

        if len(self.vertices) >= 3:
            eh_valido, mensagem = poligono_e_valido(self.vertices)
            self.resultado_validacao = mensagem

            print(f"\n{'='*50}")
            print(f"RESULTADO DA VALIDA√á√ÉO:")
            print(f"{'='*50}")
            print(f"Status: {'‚úì V√ÅLIDO' if eh_valido else '‚úó INV√ÅLIDO'}")
            print(f"Detalhes: {mensagem}")
            print(f"V√©rtices: {self.vertices}")
            print(f"{'='*50}\n")

            if eh_valido:
                self.poligono_validado = True
                # Limpa dados antigos para novo preenchimento
                self.interceptos_scanline = []
                self.scanline_step = 0
                self.pontos_raster = []
        else:
            self.resultado_validacao = "Adicione pelo menos 3 v√©rtices antes de validar"
            print(f"\n{self.resultado_validacao}\n")

    def remover_ultimo_vertice(self):
        """
        Remove o √∫ltimo v√©rtice adicionado ao pol√≠gono.

        Regras:
        - S√≥ permite remo√ß√£o se o pol√≠gono n√£o foi validado
        - Limpa dados de rasteriza√ß√£o ap√≥s remo√ß√£o
        """
        if self.vertices and not self.poligono_validado:
            self.vertices.pop()
            self.limpar_raster()

    def iniciar_preenchimento_scanline(self):
        if self.poligono_validado and not self.interceptos_scanline:
            ET, min_y, max_y = build_edge_table(self.vertices)
            self.interceptos_scanline = scanline_fill(ET, min_y, max_y)
            self.scanline_step = 0
            print(f"Preenchimento scanline iniciado com {len(self.interceptos_scanline)} linhas.")

    def avancar_scanline(self):
        if not self.poligono_validado:
            return

        if self.scanline_step < len(self.interceptos_scanline):
            y, xs = self.interceptos_scanline[self.scanline_step]

            # PREENCHIMENTO DOS INTERVALOS

            # Processa interse√ß√µes em pares (x_in√≠cio, x_fim)
            for i in range(0, len(xs), 2):
                if i + 1 < len(xs):
                    # Converte coordenadas float para inteiros
                    x_start = int(math.ceil(xs[i]))   # Arredonda para cima
                    x_end = int(math.floor(xs[i + 1])) # Arredonda para baixo

                    # Preenche todas as c√©lulas no intervalo [x_start, x_end]
                    for x in range(x_start, x_end + 1):
                        self.pontos_raster.append((x, y))

            # Avan√ßa para pr√≥xima linha de varredura
            self.scanline_step += 1

def main():
    """
    Controles do usu√°rio:
    - MOUSE: Clique esquerdo para adicionar v√©rtices
    - ENTER: Validar pol√≠gono atual
    - SPACE: Limpar tudo e come√ßar novo pol√≠gono
    - BACKSPACE: Remover √∫ltimo v√©rtice
    - N: Iniciar/avan√ßar preenchimento scanline
    - ESC: Sair da aplica√ß√£o
    """

    # INICIALIZA√á√ÉO DO PYGAME

    pygame.init()
    tela = pygame.display.set_mode((LARGURA_JANELA, ALTURA_JANELA))
    pygame.display.set_caption("Validador de Pol√≠gonos - Verifica√ß√£o de Auto-Interse√ß√£o")
    relogio = pygame.time.Clock()
    fonte = pygame.font.SysFont("consolas,monospace", 16)

    estado = EstadoApp()
    executando = True

    # LOOP PRINCIPAL

    while executando:
        pos_mouse = pygame.mouse.get_pos()

        for evento in pygame.event.get():
            if evento.type == pygame.QUIT:
                executando = False

            elif evento.type == pygame.KEYDOWN:
                if evento.key == pygame.K_ESCAPE:
                    executando = False

                elif evento.key == pygame.K_SPACE:
                    estado.vertices = []
                    estado.poligono_validado = False
                    estado.resultado_validacao = ""
                    estado.limpar_raster()

                elif evento.key == pygame.K_n:
                    if not estado.interceptos_scanline:
                        estado.iniciar_preenchimento_scanline()
                    else:
                        estado.avancar_scanline()

                elif evento.key == pygame.K_RETURN:
                    estado.validar_e_desenhar_poligono()

                elif evento.key == pygame.K_BACKSPACE:
                    estado.remover_ultimo_vertice()

            elif evento.type == pygame.MOUSEBUTTONDOWN:
                if evento.button == 1:  # Clique esquerdo
                    celula = tela_para_grade(evento.pos)
                    if celula is not None:
                        estado.adicionar_vertice(celula)

        # Fundo branco
        tela.fill(BRANCO)

        desenhar_tabuleiro(tela)

        if estado.vertices:
            # V√©rtices coloridos por estado
            desenhar_vertices(tela, estado.vertices, estado.poligono_validado)

            # Linhas conectando v√©rtices
            desenhar_linhas_preview(tela, estado.vertices, estado.poligono_validado)

            # Verifica se pol√≠gono est√° fechado
            poligono_fechado = (len(estado.vertices) >= 4 and estado.vertices[0] == estado.vertices[-1])

            # Preview da linha do mouse (s√≥ se n√£o validado e n√£o fechado)
            if not estado.poligono_validado and len(estado.vertices) > 0 and not poligono_fechado:
                pygame.draw.line(tela, LINHA_TEMPORARIA,
                               centro_celula(estado.vertices[-1]), pos_mouse, 2)

        # C√©lulas preenchidas do pol√≠gono (se validado)
        if estado.poligono_validado and estado.pontos_raster:
            desenhar_celulas_poligono(tela, estado.pontos_raster, len(estado.pontos_raster))

        # Visualiza√ß√£o da linha de varredura atual
        if estado.interceptos_scanline and estado.scanline_step < len(estado.interceptos_scanline):
            desenhar_interceptos(tela, estado.interceptos_scanline, estado.scanline_step)

        desenhar_hud(tela, fonte, estado.vertices, estado.poligono_validado,
                    estado.resultado_validacao, len(estado.pontos_raster), len(estado.pontos_raster))

        pygame.display.flip()  
        relogio.tick(FPS)    

    pygame.quit()

if __name__ == "__main__":
    main()
